# Java-Algorithms
[Sonarcloud](https://sonarcloud.io/project/overview?id=ahahaharu_Java-Algorithms)

# Задания
1.3 Контейнеры, очереди, стеки
  1) Задание 1.3.15 [Директория](Tasks/1.3/Task_15/src/org/example) (PLAN: 0.25 FACT: 0.16)
     
     **Условие:** Напишите клиент класса Queue, который принимает в командной строке аргумент k и выводит k-тую с конца строку из введённых из стандартного ввода.
  2) Задание 1.3.21 [Директория](Tasks/1.3/Task_21/src/org/example) (PLAN: 0.3 FACT: 0.5)
     
     **Условие:** Напишите метод find(), который принимает в качестве аргументов связный список и строку key и возвращает true, если какой-то узел списка содержит в поле элемента значение key, и false в противном случае.
  3) Задание 1.3.32 [Директория](Tasks/1.3/Task_32/src/org/example) (PLAN: 0.6 FACT: 0.4)
     
     **Условие:** Стеко-Очередь. Очередь с элементами поведения стека, или стеко-очередь - это тип данных, поддерживающий операции втолкнуть, вытолкнуть и занести. Сформулируйте API-интерфейс для такого АТД. Разработайте реализацию на основе связного списка.
  4) Задание 1.3.40 [Директория](Tasks/1.3/Task_40/src/org/example) (PLAN: 0.75 FACT: 0.5)

     **Условие:** Сдвиг в начало. Напишите программу для чтения символов из стандартного ввода и сохранения их в связном списке без повторов. При вводе символа, который раньше не встречался, вставьте его в начало списка. При вводе уже знакомого символа удалите его из списка и снова вставьте в начало. Назовите программу MoveToFront: она реализует известную стратегию сдвига в начало (move to front).
     
2.5 Применение сортировок

  1) Задание 2.5.14 [Директория](Tasks/2.5/Task_14/src/org/example) (PLAN: 0.5 FACT: 0.75)

     **Условие:** Сортировка доменных имён. Напишите тип данных Domain, представляющий доменные имена и содержащий метод compareTo(), который реализует естественный для доменных имён порядок обратных имён. Например, для домена cs.princeton.edu обратным именем будет edu.princeton.cs. Это удобно для анализа журналов работы в Интернете. Напишите клиент, который читает имена домена из стандатрного ввода и выводит упорядоченный список обратных доменных имён.

  2) Задание 2.5.16 [Директория](Tasks/2.5/Task_16/src/org/example) (PLAN: 0.6 FACT: 0.4)

     **Условие:** Выбор без предпочтений. Чтобы не ущемлять кандидатов, имена которых находятся в конце алфавита, на выборах губернатора Калифорнии в 2003 г. их упорядочили с помощью следующего набора символов:

      R W Q O J M V A H B S G Z X N T C I E K U P D Y F L

      Создайте тип данных, где этот порядок является естественным, и напишите клиент California с единственным статическим методом main(), который упорядочивает строки в таком порядке. Считайте, что все строки содержат только прописные буквы.

  3) Задание 2.5.21 [Директория](Tasks/2.5/Task_21/src/org/example) (PLAN: 0.5 FACT: 0.5)

     **Условие:** Многомерная сортировка. Напишите тип данных Vector для использования в методах сортировки многомерных векторов, состоящих из d целых чисел. Векторы упорядочиваются по первому компоненту, векторы с одинаковыми первыми компонентами - по второму компоненту, с одинаковыми вторыми компонентами - по третьему компоненту и т.д.

  4) Задание 2.5.8 [Директория](Tasks/2.5/Task_8/src/org/example) (PLAN: 0.25 FACT: 0.4)

     **Условие:** Напишите программу Frequency, которая читает строки из стандартного ввода и выводит количество повторений каждой строки, по убыванию частот.

3.2 Деревья бинарного поиска

  1) Задание 3.2.6 [Директория](Tasks/3.2/Task_6/src/org/example) (PLAN: 0.4 FACT: 0.5)

     **Условие:** Добавьте в класс BST метод height() для вычисления высоты дерева. Разрабо-
тайте две реализации: рекурсивный метод (требующий линейного времени и памяти, пропорциональной высоте) и метод наподобие size(), для работы которого нужно дополнительное поле в каждом узле дерева (требующий линейногоо объема памяти и константного времени на запрос).

  2) Задание 3.2.25 [Директория](Tasks/3.2/Task_25/src/org/example) (PLAN: 0.5 FACT: 0.75)

     **Условие:** Идеальная балансировка. Напишите программу, которая вставляет набор ключей в первоначально пустое ДБП так, что полученное дерево эквивалентно бинарному поиску — т.е. последовательность сравнений, выполняемых при поиске любого ключа в ДБП, совпадает с последовательностью сравнений, выполняемых при бинарном поиске в том же наборе ключей.

  3) Задание 3.2.31 [Директория](Tasks/3.2/Task_31/src/org/example) (PLAN: 0.75 FACT: 0.6)

     **Условие:** Проверка на равные ключи. Напишите метод hasNoDuplicates(), который принимает в качестве аргумента узел Node и возвращает true, если в бинарном дереве с корнем в указанном узле нет равных ключей, и false в противном случае. Считайте, что проверка из предыдущего упражнения уже выполнена.

  4) Задание 3.2.38 [Директория](Tasks/3.2/Task_38/src/org/example) (PLAN: 0.75 FACT: 0.8)

     **Условие:** Вычерчивание дерева. Добавьте в класс BST метод draw(), который вычерчивает ДБП в стиле рисунков, приведенных в тексте. Совет: используйте переменные экземпляров для хранения координат узлов и рекурсивный метод для задания значений этих переменных.


3.3 Сбалансированные деревья поиска
  1) Задание 3.3.33 [Директория](Tasks/3.3/Task_33) (PLAN: 0.3 FACT: 0.5)

     **Условие:** Проверка. Добавьте в класс RedBlackBST метод is23() для выполнения проверки, что ни у одного узла нет двух красных ссылок и нет правых красных ссылок, и метод isBalanced() для выполнения проверки, что все пути от корня к нулевым ссылкам содержат одинаковое количество черных ссылок. Объедините эти методы с кодом isBST() из упражнения 3.2.32, чтобы получить метод isRedBlackBST(), который проверяет, что дерево является красно-черным деревом бинарного поиска.

  2) Задание 3.3.40 [Директория](Tasks/3.3/Task_40) (PLAN: 0.4 FACT: 0.2)

     **Условие:** Удаление наибольшего. Реализуйте операцию deleteMax() для красно-черных ДБП. Учтите, что необходимые для этого преобразования несколько отличаются от преобразований для deleteMin(), т.к. красные ссылки направлены влево.

  3) Задание 3.3.42 [Директория](Tasks/3.3/Task_42) (PLAN: 0.5 FACT: 0.7)

     **Условие:** Подсчет красных узлов. Напишите программу, которая вычисляет процент красных узлов в заданном красно-черном ДБП. Проверьте работу программы, выполнив, по крайней мере, 100 раз вставку N случайных ключей в первоначально пустое дерево, для N = 10^4, 10^5, 10^6, и сформулируйте гипотезу.

  4) Задание 3.3.31 [Директория](Tasks/3.3/Task_31) (PLAN: 0.5 FACT: 0.8)

     **Условие:** Вычерчивание дерева. Добавьте в класс RedBlackBST метод draw(), который вычерчивает красно-черные ДБП.

3.4 Хеш-таблицы

  1) Задание 3.4.4 [Директория](Tasks/3.4/Task_4/src/org/example) (PLAN: 0.3 FACT: 0.5)

     **Условие:** Напишите программу для определения значений a и M с наименьшим M, чтобы хеш-функция (a * k) % M преобразования k-й буквы алфавита в индекс таблицы давала различные значения (без колллизий) для ключей S E A R C H X M P L. Такой результат называется идеальной хеш-функцией.

  2) Задание 3.4.25 [Директория](Tasks/3.4/Task_25/src/org/example) (PLAN: 0.4 FACT: 0.5)

     **Условие:** Кеш хешей. Добавьте в код Transaction переменную экземпляра hash, в которой метод hashCode() может сохранить хеш-значение при первом вычислении для каждого объекта, чтобы при последующих вызовах не тратить время на повторное вычисление.

  3) Задание 3.4.32 [Директория](Tasks/3.4/Task_32/src/org/example) (PLAN: 0.5 FACT: 0.4)

     **Условие:** Хеш-атака. Найдите 2^n строк, каждая длиной 2^n, которые имеют одинаковое значение hashCode() для следующей реализации:

      public int hashCode() { int hash = 0; int skip = Math.max(1, length()/8); for (int i = 0; i < length(); i += skip) hash = (hash * 37) + charAt(i); return hash; }

  4) Задание 3.4.36 [Директория](Tasks/3.4/Task_36/src/org/example) (PLAN: 0.5 FACT: 0.75)

     **Условие:** Диапазон длин списков. Напишите программу, которая вставляет N ключей int в таблицу размером N/100 с раздельными цепочками, а затем определяет длину самого короткого и самого длинного списков для N = 10^3, 10^4, 10^5 и 10^6

5.1 Сортировка строк

  1) Задание 5.1.7 [Директория](Tasks/5.1/Task_7/src/org/example) (PLAN: 0.3 FACT: 0.4)

     **Условие:** Разработайте реализацию распределяющего подсчёта, в котором используется массив объектов Queue.

  2) Задание 5.1.9 [Директория](Tasks/5.1/Task_9/src/org/example) (PLAN: 0.4 FACT: 0.6)

     **Условие:** Разработайте реализацию LSD-сортировки строк, которая способна работать со строками переменной длины.

  3) Задание 5.1.14 [Директория](Tasks/5.1/Task_14/src/org/example) (PLAN: 0.5 FACT: 0.7)

     **Условие:** Сортировка массивов. Разработайте метод, в котором тречастная быстрая сортировка строк применяется для ключей, представляющих собой массивы целых чисел.

  4) Задание 5.1.18 [Директория](Tasks/5.1/Task_18/src/org/example) (PLAN: 0.5 FACT: 0.4)

     **Условие:** Случайные десятичные ключи. Напишите статический метод randomDecimalKeys? который принимает в качестве аргументов целочисленные значения N и W и возвращает массив N строковых значений, каждое из которых является W-значным десятичным числом.

5.2 Trie-деревья

  1) Задание 5.2.6 [Директория](Tasks/5.2/Task_6/src/org/example) (PLAN: 0.4 FACT: 0.4)

     **Условие:** Реализуйте API для типа данных StringSET

![image](https://github.com/ahahaharu/Java-Algorithms/assets/112519966/4095c7b3-0254-4215-b6f6-08f61b503668)

  2) Задание 5.2.9 [Директория](Tasks/5.2/Task_9/src/org/example) (PLAN: 0.5 FACT: 0.6)

     **Условие:** Реализуйте метод keys() и расширенные операции - longestPrefixOf(), keysWithPrefix() и keysThatMatch() - для класса TST.

  3) Задание 5.2.20 [Директория](Tasks/5.2/Task_20/src/org/example) (PLAN: 0.4 FACT: 0.3)

     **Условие:** Добавьте в класс StringSET метод containsPrefix(), который принимает в качестве аргумента строку s и возвращает true, если множество содержит строку с префиксом s.

  4) Задание 5.2.22 [Директория](Tasks/5.2/Task_22/src/org/example) (PLAN: 0.5 FACT: 0.7)

     **Условие:** Допустим, что мартышка, печатающая на компьютере, создаёт случайные слова, добавляя к текущему слову одну из 26 возможных латинских буквы с вероятностью  p и заканчивая слово с вероятностью  1 - 26p. Напишите программу для оценки распределния частот различных длин полученных слов. Если слово появилось несколько раз, считайте его только один раз.
  
5.3 Поиск подстрок

  1) Задание 5.3.1 [Директория](Tasks/5.3/Task_1/src/org/example) (PLAN: 0.3 FACT: 0.4)

     **Условие:** Напишите примитивную реализацию поисска подстроки Brute, используя тот же API, что и алгоритм 5.6.

![image](https://github.com/ahahaharu/Java-Algorithms/assets/112519966/697b8c67-a62a-451e-b93d-5b3139e7d3d9)

     
  2) Задание 5.3.4 [Директория](Tasks/5.3/Task_4/src/org/example) (PLAN: 0.4 FACT: 0.6)

     **Условие:** Напишите эффективный метод, который принимает в качестве аргументов строку txt и целое число M и возвращает позицию первого вхождения M последовательных пробелов в строку или txt.length, если такого вхождения нет.

  3) Задание 5.3.9 [Директория](Tasks/5.3/Task_9/src/org/example) (PLAN: 0.5 FACT: 0.6)

     **Условие:** Добавьте в класс RabinKarp метод count(), который подсчитывает вхождения подстроки, и метод searchAll(), который выводит все вхождения.

  4) Задание 5.3.33 [Директория](Tasks/5.3/Task_33/src/org/example) (PLAN: 0.5 FACT: 0.2)

     **Условие:** Реализуйте метод longRandomPrime() для класса RabinKarp.

5.4 Регулярные выражения

