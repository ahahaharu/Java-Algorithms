# Java-Algorithms
[Sonarcloud](https://sonarcloud.io/project/overview?id=ahahaharu_Java-Algorithms)

# Задания
1.3 Контейнеры, очереди, стеки
  1) Задание 1.3.15 [Директория](Tasks/1.3/Task_15/src/org/example) (PLAN: 0.25 FACT: 0.16)
     
     **Условие:** Напишите клиент класса Queue, который принимает в командной строке аргумент k и выводит k-тую с конца строку из введённых из стандартного ввода.
  2) Задание 1.3.21 [Директория](Tasks/1.3/Task_21/src/org/example) (PLAN: 0.3 FACT: 0.5)
     
     **Условие:** Напишите метод find(), который принимает в качестве аргументов связный список и строку key и возвращает true, если какой-то узел списка содержит в поле элемента значение key, и false в противном случае.
  3) Задание 1.3.32 [Директория](Tasks/1.3/Task_32/src/org/example) (PLAN: 0.6 FACT: 0.4)
     
     **Условие:** Стеко-Очередь. Очередь с элементами поведения стека, или стеко-очередь - это тип данных, поддерживающий операции втолкнуть, вытолкнуть и занести. Сформулируйте API-интерфейс для такого АТД. Разработайте реализацию на основе связного списка.
  4) Задание 1.3.40 [Директория](Tasks/1.3/Task_40/src/org/example) (PLAN: 0.75 FACT: 0.5)

     **Условие:** Сдвиг в начало. Напишите программу для чтения символов из стандартного ввода и сохранения их в связном списке без повторов. При вводе символа, который раньше не встречался, вставьте его в начало списка. При вводе уже знакомого символа удалите его из списка и снова вставьте в начало. Назовите программу MoveToFront: она реализует известную стратегию сдвига в начало (move to front).
     
2.5 Применение сортировок

3.2 Деревья бинарного поиска

3.3 Сбалансированные деревья поиска
  1) Задание 3.3.33 [Директория](Tasks/3.3/Task_33) (PLAN: 0.3 FACT: 0.5)

     **Условие:** Проверка. Добавьте в класс RedBlackBST метод is23() для выполнения проверки, что ни у одного узла нет двух красных ссылок и нет правых красных ссылок, и метод isBalanced() для выполнения проверки, что все пути от корня к нулевым ссылкам содержат одинаковое количество черных ссылок. Объедините эти методы с кодом isBST() из упражнения 3.2.32, чтобы получить метод isRedBlackBST(), который проверяет, что дерево является красно-черным деревом бинарного поиска.

  2) Задание 3.3.40 [Директория](Tasks/3.3/Task_40) (PLAN: 0.4 FACT: 0.2)

     **Условие:** Удаление наибольшего. Реализуйте операцию deleteMax() для красно-черных ДБП. Учтите, что необходимые для этого преобразования несколько отличаются от преобразований для deleteMin(), т.к. красные ссылки направлены влево.

  3) Задание 3.3.42 [Директория](Tasks/3.3/Task_42) (PLAN: 0.5 FACT: 0.7)

     **Условие:** Подсчет красных узлов. Напишите программу, которая вычисляет процент красных узлов в заданном красно-черном ДБП. Проверьте работу программы, выполнив, по крайней мере, 100 раз вставку N случайных ключей в первоначально пустое дерево, для N = 10^4, 10^5, 10^6, и сформулируйте гипотезу.

  4) Задание 3.3.31 [Директория](Tasks/3.3/Task_31) (PLAN: 0.5 FACT: 0.8)

     **Условие:** Вычерчивание дерева. Добавьте в класс RedBlackBST метод draw(), который вычерчивает красно-черные ДБП.

3.4 Хеш-таблицы

5.1 Сортировка строк

5.2 Trie-деревья

5.3 Поиск подстрок

5.4 Регулярные выражения

